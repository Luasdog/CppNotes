# 虚函数

> **虚函数就是支持子类重写、基类指针/引用调用时能动态选择正确函数的一种机制，是 C++ 实现运行时多态性的核心。**
> 
> **虚函数**就是在基类（父类）中用 `virtual` 关键字声明的成员函数，允许在**子类中重新定义（重写）**，并且通过**基类指针或引用**调用时，能够**动态决定实际调用子类的版本**。
> 
> **虚函数 = 支持运行时动态绑定（多态性）的函数。**

---

## 为什么需要虚函数？

正常情况下，如果你用**父类指针/引用**去调用一个函数，默认是**编译时绑定**（根据指针类型确定调用哪个函数）。

但如果一个函数是**虚函数**，那么编译器会**延迟到运行时**，根据指针/引用指向的对象实际类型去选择调用哪个函数。这就是**运行时多态**！

---

## 例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { // 虚函数
        cout << "Base::show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 重写父类的虚函数
        cout << "Derived::show()" << endl;
    }
};

int main() {
    Base* p = new Derived(); // 父类指针指向子类对象
    p->show(); // 调用的是 Derived::show()，而不是 Base::show()
    delete p;
}
```

**输出：**
```
Derived::show()
```
虽然 `p` 是 `Base*` 类型，但由于 `show()` 是**虚函数**，所以调用的是 **Derived** 的版本。

---

| 术语        | 解释 |
|:-----------|:-----|
| 静态绑定    | 编译期确定调用哪个函数（非虚函数默认就是这样） |
| 动态绑定    | 运行期根据对象实际类型决定调用哪个函数（虚函数支持动态绑定） |
| 多态性      | 同一调用接口，根据对象不同表现出不同的行为 |
| override关键字 | C++11 引入，用来明确表示重写虚函数，增强可读性和安全性 |

---

| 特性            | 说明 |
|:----------------|:-----|
| `virtual` 修饰函数 | 告诉编译器这个函数将来可能会被子类重写 |
| 必须通过**基类指针/引用**调用 | 才能体现出多态性，否则就是正常调用 |
| 支持**运行时多态** | 调用的版本根据实际对象决定 |

---

## 为什么不用虚函数的话就不行？

比如如果没有 `virtual`，你写：

```cpp
Base* p = new Derived();
p->show(); // 调用的就是 Base::show()，而不是 Derived::show()
```
那调用的永远是 Base 版本的函数！失去了多态的意义。

---

## 虚函数相关的机制
虚函数背后实际上是靠 **虚函数表（vtable）+ 虚指针（vptr）** 实现的：
- 每个有虚函数的类会生成一个**vtable**。
- 每个对象内部隐藏一个指向 vtable 的指针（vptr）。
- 调用虚函数时，**通过vptr查vtable找到正确的函数地址**，然后跳转执行。

---

# 内联函数

> **内联函数是通过在编译阶段把函数调用展开成代码本身，来提高程序执行效率的一种优化方式，适合短小频繁调用的场景，但由编译器最终决定是否真的内联。**
> 
> **内联函数（inline function）**是一种**在编译阶段**，把**函数调用的地方，直接用函数体的代码展开替换**，从而**消除函数调用开销**、提高运行效率的技术。

简单说：
> **内联函数 = 编译时把函数"复制粘贴"到调用点，而不是跳转调用。**

---

## 例子：正常函数 vs 内联函数

普通函数：

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); // 正常调用 -> 压栈、跳转到 add 函数、执行、返回
}
```

内联函数写法：

```cpp
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); 
    // 编译器看到inline，会把这里直接替换成：
    // int res = 1 + 2;
}
```

✅ 也就是说，`inline` 后，**`add(1,2)` 直接被替换成了 `1+2`，没有函数调用开销。**

---

## 内联函数的作用

| 作用                  | 解释 |
|:----------------------|:-----|
| 消除函数调用开销        | 没有函数压栈、跳转、返回的过程，直接执行代码 |
| 提高小函数的执行速度    | 特别是那种非常短小、频繁调用的函数，比如加法、取最大值 |
| 使程序更紧凑（小函数）  | 对小代码块很有好处 |

---

## 注意！inline不是强制的！

即使你写了 `inline`，  
**编译器可以决定是否真正内联**。

> 编译器会根据函数的复杂度、大小、递归等综合因素决定是否内联，  
> `inline`只是一个**建议（hint）**，而不是强制命令！

---

## 什么情况下适合用内联函数？

✅ 很小、很短的函数，比如：
```cpp
inline int max(int a, int b) { return a > b ? a : b; }
```
✅ 很频繁调用的小工具函数。
✅ 对性能要求非常高、且函数非常简单的场景。

---

## 什么情况下**不应该**用内联？

❌ 函数体很大（会导致代码膨胀，反而慢）  
❌ 函数里有复杂循环、递归（编译器通常拒绝内联递归函数）  
❌ 很少调用的函数（内联没意义）

---

## 总结

| 特性          | 内容 |
|:--------------|:-----|
| 定义 | 使用 `inline` 关键字，建议编译器内联 |
| 本质 | 函数调用点展开成函数体代码，省去函数调用开销 |
| 是否强制 | ❌ 编译器可以自己决定是否真正内联 |
| 适合用在 | 小函数，频繁调用，性能要求高的地方 |

---

## 补充

- 类的成员函数，如果在类定义里面写了函数体，**默认就是内联函数**（即使没写 `inline`）。
- C++11 以后还可以写 `inline static`，比如在类里声明静态成员变量。

---

