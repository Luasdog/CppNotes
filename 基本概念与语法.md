# 虚函数

> **虚函数就是支持子类重写、基类指针/引用调用时能动态选择正确函数的一种机制，是 C++ 实现运行时多态性的核心。**
> 
> **虚函数**就是在基类（父类）中用 `virtual` 关键字声明的成员函数，允许在**子类中重新定义（重写）**，并且通过**基类指针或引用**调用时，能够**动态决定实际调用子类的版本**。
> 
> **虚函数 = 支持运行时动态绑定（多态性）的函数。**

---

## 为什么需要虚函数？

正常情况下，如果你用**父类指针/引用**去调用一个函数，默认是**编译时绑定**（根据指针类型确定调用哪个函数）。

但如果一个函数是**虚函数**，那么编译器会**延迟到运行时**，根据指针/引用指向的对象实际类型去选择调用哪个函数。这就是**运行时多态**！

---

## 例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { // 虚函数
        cout << "Base::show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 重写父类的虚函数
        cout << "Derived::show()" << endl;
    }
};

int main() {
    Base* p = new Derived(); // 父类指针指向子类对象
    p->show(); // 调用的是 Derived::show()，而不是 Base::show()
    delete p;
}
```

**输出：**
```
Derived::show()
```
虽然 `p` 是 `Base*` 类型，但由于 `show()` 是**虚函数**，所以调用的是 **Derived** 的版本。

---

| 术语        | 解释 |
|:-----------|:-----|
| 静态绑定    | 编译期确定调用哪个函数（非虚函数默认就是这样） |
| 动态绑定    | 运行期根据对象实际类型决定调用哪个函数（虚函数支持动态绑定） |
| 多态性      | 同一调用接口，根据对象不同表现出不同的行为 |
| override关键字 | C++11 引入，用来明确表示重写虚函数，增强可读性和安全性 |

---

| 特性            | 说明 |
|:----------------|:-----|
| `virtual` 修饰函数 | 告诉编译器这个函数将来可能会被子类重写 |
| 必须通过**基类指针/引用**调用 | 才能体现出多态性，否则就是正常调用 |
| 支持**运行时多态** | 调用的版本根据实际对象决定 |

---

## 为什么不用虚函数的话就不行？

比如如果没有 `virtual`，你写：

```cpp
Base* p = new Derived();
p->show(); // 调用的就是 Base::show()，而不是 Derived::show()
```
那调用的永远是 Base 版本的函数！失去了多态的意义。

---

## 虚函数相关的机制
虚函数背后实际上是靠 **虚函数表（vtable）+ 虚指针（vptr）** 实现的：
- 每个有虚函数的类会生成一个**vtable**。
- 每个对象内部隐藏一个指向 vtable 的指针（vptr）。
- 调用虚函数时，**通过vptr查vtable找到正确的函数地址**，然后跳转执行。

---

# 内联函数

> **内联函数是通过在编译阶段把函数调用展开成代码本身，来提高程序执行效率的一种优化方式，适合短小频繁调用的场景，但由编译器最终决定是否真的内联。**
> 
> **内联函数（inline function）**是一种**在编译阶段**，把**函数调用的地方，直接用函数体的代码展开替换**，从而**消除函数调用开销**、提高运行效率的技术。

简单说：
> **内联函数 = 编译时把函数"复制粘贴"到调用点，而不是跳转调用。**

---

## 例子：正常函数 vs 内联函数

普通函数：

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); // 正常调用 -> 压栈、跳转到 add 函数、执行、返回
}
```

内联函数写法：

```cpp
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); 
    // 编译器看到inline，会把这里直接替换成：
    // int res = 1 + 2;
}
```

✅ 也就是说，`inline` 后，**`add(1,2)` 直接被替换成了 `1+2`，没有函数调用开销。**

---

## 内联函数的作用

| 作用                  | 解释 |
|:----------------------|:-----|
| 消除函数调用开销        | 没有函数压栈、跳转、返回的过程，直接执行代码 |
| 提高小函数的执行速度    | 特别是那种非常短小、频繁调用的函数，比如加法、取最大值 |
| 使程序更紧凑（小函数）  | 对小代码块很有好处 |

---

## 注意！inline不是强制的！

即使你写了 `inline`，  
**编译器可以决定是否真正内联**。

> 编译器会根据函数的复杂度、大小、递归等综合因素决定是否内联，  
> `inline`只是一个**建议（hint）**，而不是强制命令！

---

## 什么情况下适合用内联函数？

✅ 很小、很短的函数，比如：
```cpp
inline int max(int a, int b) { return a > b ? a : b; }
```
✅ 很频繁调用的小工具函数。
✅ 对性能要求非常高、且函数非常简单的场景。

---

## 什么情况下**不应该**用内联？

❌ 函数体很大（会导致代码膨胀，反而慢）  
❌ 函数里有复杂循环、递归（编译器通常拒绝内联递归函数）  
❌ 很少调用的函数（内联没意义）

---

## 总结

| 特性          | 内容 |
|:--------------|:-----|
| 定义 | 使用 `inline` 关键字，建议编译器内联 |
| 本质 | 函数调用点展开成函数体代码，省去函数调用开销 |
| 是否强制 | ❌ 编译器可以自己决定是否真正内联 |
| 适合用在 | 小函数，频繁调用，性能要求高的地方 |

---

## 补充

- 类的成员函数，如果在类定义里面写了函数体，**默认就是内联函数**（即使没写 `inline`）。
- C++11 以后还可以写 `inline static`，比如在类里声明静态成员变量。

---

# 类型窄化

类型窄化（Narrowing Conversion）指的是在类型转换过程中，由于目标类型的表示范围比源类型小，导致转换结果的精度丧失或者溢出。

将一个较大范围或较高精度的类型转换为一个较小范围或较低精度的类型。

通常，类型窄化可能会导致数据丢失或错误，因为目标类型无法表示源类型的所有值。

```cpp
int main() {
   int a = 1.2; // ok
   int b = {1.2}; // error

   float c = 1e70; // ok
   float d = {1e70}; // error

   float e = (unsigned long long)-1; // ok
   float f = {(unsigned long long)-1}; // error
   float g = (unsigned long long)1; // ok
   float h = {(unsigned long long)1}; // ok

   const int i = 1000;
   const int j = 2;
   char k = i; // ok
   char l = {i}; // error

   char m = j; // ok
   char m = {j}; // ok，因为是const类型，这里如果去掉const属性，也会报错
}
```
分析：
这段代码展示了一些 C++ 中的类型转换、初始化方式以及在不同情况下出现的错误。让我们逐步分析各行代码及其行为：

### 1. **`int a = 1.2; // ok`**

* **原因**：这行代码是合法的，因为 C++ 允许从浮点数（如 `1.2`）到整数类型（如 `int`）的隐式类型转换。在这种转换中，浮点数的小数部分会被截断，只保留整数部分。因此，`a` 的值会是 `1`。
* **结果**：`a` 的值为 `1`。

### 2. **`int b = {1.2}; // error`**

* **原因**：这行代码使用了**列表初始化**（brace initialization）。在列表初始化中，C++ 严格要求类型匹配，并且不会进行隐式转换。因此，`1.2`（浮点数）不能直接初始化一个 `int`（整数），所以会导致错误。
* **错误信息**：编译器会提示类型不匹配，因为 `1.2` 是 `double` 类型，不能自动转换为 `int`。
* **解决方法**：可以使用显式的类型转换：

  ```cpp
  int b = static_cast<int>(1.2);
  ```

### 3. **`float c = 1e70; // ok`**

* **原因**：这里 `1e70` 是一个浮点常量（科学记数法表示），它表示一个非常大的值（`1 * 10^70`）。`float` 可以存储这个值，尽管它可能会溢出（如果 `float` 类型的最大值不能表示这么大的数字）。不过，编译器允许这种赋值，因为 `float` 可以存储浮点数。
* **结果**：`c` 会存储一个非常大的浮点数，可能会溢出到 `infinity`（无穷大）。

### 4. **`float d = {1e70}; // error`**

* **原因**：这是**列表初始化**，同样严格要求类型匹配，并且不允许进行隐式类型转换。在这里，`1e70` 是 `double` 类型，`float` 类型的变量无法接受过大的 `double` 值，且列表初始化不会进行隐式转换，导致错误。
* **错误信息**：编译器会提示类型不匹配，不能将 `double` 转换为 `float`。

### 5. **`float e = (unsigned long long)-1; // ok`**

* **原因**：这是一个显式类型转换，`-1` 先被转换为 `unsigned long long`，然后将其赋值给 `float`。由于 `unsigned long long` 是一个非常大的无符号整数，转换为 `float` 时会根据 `float` 的精度进行转换，通常会得到一个很大的值。
* **结果**：`e` 的值可能是一个非常大的浮点数，接近 `unsigned long long` 类型的最大值，但不会引发错误。

### 6. **`float f = {(unsigned long long)-1}; // error`**

* **原因**：这行代码使用了**列表初始化**，而列表初始化不允许进行类型转换，特别是当类型之间的转换没有明确的匹配时。`(unsigned long long)-1` 是一个无符号大整数，不能直接初始化为 `float` 类型。
* **错误信息**：编译器会提示类型不匹配。

### 7. **`float g = (unsigned long long)1; // ok`**

* **原因**：这行代码首先将 `1` 转换为 `unsigned long long` 类型，然后再将其转换为 `float`。这种显式类型转换是合法的，并且会将值 `1` 转换为浮点数 `1.0`。
* **结果**：`g` 的值为 `1.0`。

### 8. **`float h = {(unsigned long long)1}; // ok`**

* **原因**：这行代码使用了列表初始化，但因为 `unsigned long long` 是一个常量值 `1`，它可以通过隐式转换被初始化为 `float` 类型。所以这行代码是合法的。
* **结果**：`h` 的值为 `1.0`。

### 9. **`const int i = 1000;`**

* **原因**：这里声明了一个 `const` 常量 `i`，其值为 `1000`。`const` 修饰符表示该变量是常量，无法在程序中修改。

### 10. **`const int j = 2;`**

* **原因**：声明了另一个 `const` 常量 `j`，其值为 `2`。

### 11. **`char k = i; // ok`**

* **原因**：`i` 的值是 `1000`，将其赋值给 `char` 类型时，编译器会将 `1000` 转换为 `char`，但 `char` 类型的范围是 `-128` 到 `127`（通常为 `signed char`）。因此，`1000` 会被**截断**，结果会是 `1000 % 256 = 232`，并存储为字符值 `232`。
* **结果**：`k` 会存储字符值 `232`，不会报错。

### 12. **`char l = {i}; // error`**

* **原因**：这里使用了**列表初始化**。列表初始化不允许进行隐式类型转换，因此不能将 `const int` 类型的 `i`（值为 `1000`）直接初始化为 `char`。会导致编译错误。
* **错误信息**：编译器会提示类型不匹配，不能将 `int` 转换为 `char`。

### 13. **`char m = j; // ok`**

* **原因**：`j` 的值是 `2`，`char` 类型可以直接存储这个值，因此 `m` 会被赋值为 `2`。
* **结果**：`m` 的值为 `2`。

### 14. **`char m = {j}; // ok`**

* **原因**：这里使用了列表初始化，将 `const int` 类型的常量 `j`（值为 `2`）初始化为 `char` 类型。由于 `2` 可以被 `char` 接受，且 `const` 修饰符在这里没有影响，因此是合法的。
* **结果**：`m` 的值为 `2`。

### 15. **`char m = {j}; // error` (如果去掉 `const` 的话)**

* **原因**：当去掉 `const` 时，`j` 就变成了一个非常量整数。在这种情况下，`char` 只能接受一个明确的常量值，而不能接受非 `const` 的值进行列表初始化。
* **错误信息**：编译器会提示不能进行类型转换，因为 `char` 只能通过常量值初始化。

### 总结：

* **列表初始化**（brace initialization）是一种严格的初始化方式，它要求类型匹配，并且**严格限制**隐式转换。
* **隐式转换**通常在简单赋值时有效，但在使用列表初始化时，C++ 强制要求类型完全匹配。
* 对于 **const** 常量，可以进行隐式转换，但去掉 `const` 后可能会遇到类型不匹配的错误。