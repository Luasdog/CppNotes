# 虚函数

> **虚函数就是支持子类重写、基类指针/引用调用时能动态选择正确函数的一种机制，是 C++ 实现运行时多态性的核心。**
> 
> **虚函数**就是在基类（父类）中用 `virtual` 关键字声明的成员函数，允许在**子类中重新定义（重写）**，并且通过**基类指针或引用**调用时，能够**动态决定实际调用子类的版本**。
> 
> **虚函数 = 支持运行时动态绑定（多态性）的函数。**

---

## 为什么需要虚函数？

正常情况下，如果你用**父类指针/引用**去调用一个函数，默认是**编译时绑定**（根据指针类型确定调用哪个函数）。

但如果一个函数是**虚函数**，那么编译器会**延迟到运行时**，根据指针/引用指向的对象实际类型去选择调用哪个函数。这就是**运行时多态**！

---

## 例子

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { // 虚函数
        cout << "Base::show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 重写父类的虚函数
        cout << "Derived::show()" << endl;
    }
};

int main() {
    Base* p = new Derived(); // 父类指针指向子类对象
    p->show(); // 调用的是 Derived::show()，而不是 Base::show()
    delete p;
}
```

**输出：**
```
Derived::show()
```
虽然 `p` 是 `Base*` 类型，但由于 `show()` 是**虚函数**，所以调用的是 **Derived** 的版本。

---

| 术语        | 解释 |
|:-----------|:-----|
| 静态绑定    | 编译期确定调用哪个函数（非虚函数默认就是这样） |
| 动态绑定    | 运行期根据对象实际类型决定调用哪个函数（虚函数支持动态绑定） |
| 多态性      | 同一调用接口，根据对象不同表现出不同的行为 |
| override关键字 | C++11 引入，用来明确表示重写虚函数，增强可读性和安全性 |

---

| 特性            | 说明 |
|:----------------|:-----|
| `virtual` 修饰函数 | 告诉编译器这个函数将来可能会被子类重写 |
| 必须通过**基类指针/引用**调用 | 才能体现出多态性，否则就是正常调用 |
| 支持**运行时多态** | 调用的版本根据实际对象决定 |

---

## 为什么不用虚函数的话就不行？

比如如果没有 `virtual`，你写：

```cpp
Base* p = new Derived();
p->show(); // 调用的就是 Base::show()，而不是 Derived::show()
```
那调用的永远是 Base 版本的函数！失去了多态的意义。

---

## 虚函数相关的机制
虚函数背后实际上是靠 **虚函数表（vtable）+ 虚指针（vptr）** 实现的：
- 每个有虚函数的类会生成一个**vtable**。
- 每个对象内部隐藏一个指向 vtable 的指针（vptr）。
- 调用虚函数时，**通过vptr查vtable找到正确的函数地址**，然后跳转执行。

---

# 内联函数

> **内联函数是通过在编译阶段把函数调用展开成代码本身，来提高程序执行效率的一种优化方式，适合短小频繁调用的场景，但由编译器最终决定是否真的内联。**
> 
> **内联函数（inline function）**是一种**在编译阶段**，把**函数调用的地方，直接用函数体的代码展开替换**，从而**消除函数调用开销**、提高运行效率的技术。

简单说：
> **内联函数 = 编译时把函数"复制粘贴"到调用点，而不是跳转调用。**

---

## 例子：正常函数 vs 内联函数

普通函数：

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); // 正常调用 -> 压栈、跳转到 add 函数、执行、返回
}
```

内联函数写法：

```cpp
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int res = add(1, 2); 
    // 编译器看到inline，会把这里直接替换成：
    // int res = 1 + 2;
}
```

✅ 也就是说，`inline` 后，**`add(1,2)` 直接被替换成了 `1+2`，没有函数调用开销。**

---

## 内联函数的作用

| 作用                  | 解释 |
|:----------------------|:-----|
| 消除函数调用开销        | 没有函数压栈、跳转、返回的过程，直接执行代码 |
| 提高小函数的执行速度    | 特别是那种非常短小、频繁调用的函数，比如加法、取最大值 |
| 使程序更紧凑（小函数）  | 对小代码块很有好处 |

---

## 注意！inline不是强制的！

即使你写了 `inline`，  
**编译器可以决定是否真正内联**。

> 编译器会根据函数的复杂度、大小、递归等综合因素决定是否内联，  
> `inline`只是一个**建议（hint）**，而不是强制命令！

---

## 什么情况下适合用内联函数？

✅ 很小、很短的函数，比如：
```cpp
inline int max(int a, int b) { return a > b ? a : b; }
```
✅ 很频繁调用的小工具函数。
✅ 对性能要求非常高、且函数非常简单的场景。

---

## 什么情况下**不应该**用内联？

❌ 函数体很大（会导致代码膨胀，反而慢）  
❌ 函数里有复杂循环、递归（编译器通常拒绝内联递归函数）  
❌ 很少调用的函数（内联没意义）

---

## 总结

| 特性          | 内容 |
|:--------------|:-----|
| 定义 | 使用 `inline` 关键字，建议编译器内联 |
| 本质 | 函数调用点展开成函数体代码，省去函数调用开销 |
| 是否强制 | ❌ 编译器可以自己决定是否真正内联 |
| 适合用在 | 小函数，频繁调用，性能要求高的地方 |

---

## 补充

- 类的成员函数，如果在类定义里面写了函数体，**默认就是内联函数**（即使没写 `inline`）。
- C++11 以后还可以写 `inline static`，比如在类里声明静态成员变量。

---

# 类型窄化

类型窄化（Narrowing Conversion）指的是在类型转换过程中，由于目标类型的表示范围比源类型小，导致转换结果的精度丧失或者溢出。

将一个较大范围或较高精度的类型转换为一个较小范围或较低精度的类型。

通常，类型窄化可能会导致数据丢失或错误，因为目标类型无法表示源类型的所有值。

```cpp
int main() {
   int a = 1.2; // ok
   int b = {1.2}; // error

   float c = 1e70; // ok
   float d = {1e70}; // error

   float e = (unsigned long long)-1; // ok
   float f = {(unsigned long long)-1}; // error
   float g = (unsigned long long)1; // ok
   float h = {(unsigned long long)1}; // ok

   const int i = 1000;
   const int j = 2;
   char k = i; // ok
   char l = {i}; // error

   char m = j; // ok
   char m = {j}; // ok，因为是const类型，这里如果去掉const属性，也会报错
}
```
分析：
这段代码展示了一些 C++ 中的类型转换、初始化方式以及在不同情况下出现的错误。让我们逐步分析各行代码及其行为：

### 1. **`int a = 1.2; // ok`**

* **原因**：这行代码是合法的，因为 C++ 允许从浮点数（如 `1.2`）到整数类型（如 `int`）的隐式类型转换。在这种转换中，浮点数的小数部分会被截断，只保留整数部分。因此，`a` 的值会是 `1`。
* **结果**：`a` 的值为 `1`。

### 2. **`int b = {1.2}; // error`**

* **原因**：这行代码使用了**列表初始化**（brace initialization）。在列表初始化中，C++ 严格要求类型匹配，并且不会进行隐式转换。因此，`1.2`（浮点数）不能直接初始化一个 `int`（整数），所以会导致错误。
* **错误信息**：编译器会提示类型不匹配，因为 `1.2` 是 `double` 类型，不能自动转换为 `int`。
* **解决方法**：可以使用显式的类型转换：

  ```cpp
  int b = static_cast<int>(1.2);
  ```

### 3. **`float c = 1e70; // ok`**

* **原因**：这里 `1e70` 是一个浮点常量（科学记数法表示），它表示一个非常大的值（`1 * 10^70`）。`float` 可以存储这个值，尽管它可能会溢出（如果 `float` 类型的最大值不能表示这么大的数字）。不过，编译器允许这种赋值，因为 `float` 可以存储浮点数。
* **结果**：`c` 会存储一个非常大的浮点数，可能会溢出到 `infinity`（无穷大）。

### 4. **`float d = {1e70}; // error`**

* **原因**：这是**列表初始化**，同样严格要求类型匹配，并且不允许进行隐式类型转换。在这里，`1e70` 是 `double` 类型，`float` 类型的变量无法接受过大的 `double` 值，且列表初始化不会进行隐式转换，导致错误。
* **错误信息**：编译器会提示类型不匹配，不能将 `double` 转换为 `float`。

### 5. **`float e = (unsigned long long)-1; // ok`**

* **原因**：这是一个显式类型转换，`-1` 先被转换为 `unsigned long long`，然后将其赋值给 `float`。由于 `unsigned long long` 是一个非常大的无符号整数，转换为 `float` 时会根据 `float` 的精度进行转换，通常会得到一个很大的值。
* **结果**：`e` 的值可能是一个非常大的浮点数，接近 `unsigned long long` 类型的最大值，但不会引发错误。

### 6. **`float f = {(unsigned long long)-1}; // error`**

* **原因**：这行代码使用了**列表初始化**，而列表初始化不允许进行类型转换，特别是当类型之间的转换没有明确的匹配时。`(unsigned long long)-1` 是一个无符号大整数，不能直接初始化为 `float` 类型。
* **错误信息**：编译器会提示类型不匹配。

### 7. **`float g = (unsigned long long)1; // ok`**

* **原因**：这行代码首先将 `1` 转换为 `unsigned long long` 类型，然后再将其转换为 `float`。这种显式类型转换是合法的，并且会将值 `1` 转换为浮点数 `1.0`。
* **结果**：`g` 的值为 `1.0`。

### 8. **`float h = {(unsigned long long)1}; // ok`**

* **原因**：这行代码使用了列表初始化，但因为 `unsigned long long` 是一个常量值 `1`，它可以通过隐式转换被初始化为 `float` 类型。所以这行代码是合法的。
* **结果**：`h` 的值为 `1.0`。

### 9. **`const int i = 1000;`**

* **原因**：这里声明了一个 `const` 常量 `i`，其值为 `1000`。`const` 修饰符表示该变量是常量，无法在程序中修改。

### 10. **`const int j = 2;`**

* **原因**：声明了另一个 `const` 常量 `j`，其值为 `2`。

### 11. **`char k = i; // ok`**

* **原因**：`i` 的值是 `1000`，将其赋值给 `char` 类型时，编译器会将 `1000` 转换为 `char`，但 `char` 类型的范围是 `-128` 到 `127`（通常为 `signed char`）。因此，`1000` 会被**截断**，结果会是 `1000 % 256 = 232`，并存储为字符值 `232`。
* **结果**：`k` 会存储字符值 `232`，不会报错。

### 12. **`char l = {i}; // error`**

* **原因**：这里使用了**列表初始化**。列表初始化不允许进行隐式类型转换，因此不能将 `const int` 类型的 `i`（值为 `1000`）直接初始化为 `char`。会导致编译错误。
* **错误信息**：编译器会提示类型不匹配，不能将 `int` 转换为 `char`。

### 13. **`char m = j; // ok`**

* **原因**：`j` 的值是 `2`，`char` 类型可以直接存储这个值，因此 `m` 会被赋值为 `2`。
* **结果**：`m` 的值为 `2`。

### 14. **`char m = {j}; // ok`**

* **原因**：这里使用了列表初始化，将 `const int` 类型的常量 `j`（值为 `2`）初始化为 `char` 类型。由于 `2` 可以被 `char` 接受，且 `const` 修饰符在这里没有影响，因此是合法的。
* **结果**：`m` 的值为 `2`。

### 15. **`char m = {j}; // error` (如果去掉 `const` 的话)**

* **原因**：当去掉 `const` 时，`j` 就变成了一个非常量整数。在这种情况下，`char` 只能接受一个明确的常量值，而不能接受非 `const` 的值进行列表初始化。
* **错误信息**：编译器会提示不能进行类型转换，因为 `char` 只能通过常量值初始化。

### 总结：

* **列表初始化**（brace initialization）是一种严格的初始化方式，它要求类型匹配，并且**严格限制**隐式转换。
* **隐式转换**通常在简单赋值时有效，但在使用列表初始化时，C++ 强制要求类型完全匹配。
* 对于 **const** 常量，可以进行隐式转换，但去掉 `const` 后可能会遇到类型不匹配的错误。

# 拷贝构造函数与拷贝复制运算符

## 拷贝构造（Copy Constructor）

### 定义：

> 用**一个已有对象**来**创建一个新的对象**，这时候调用的就是 **拷贝构造函数**。

### 语法：

```cpp
T(const T& other); // 参数是 const 引用
```

### 示例：

```cpp
class Person {
public:
    Person(const Person& other) {
        std::cout << "拷贝构造函数被调用\n";
    }
};

Person p1;
Person p2 = p1; // ← 调用了拷贝构造函数
```

---

## 拷贝赋值（Copy Assignment）

### 定义：

> 用**一个已有对象的值**去**赋值给另一个已经存在的对象**，这时会调用 **拷贝赋值运算符**。

### 语法：

```cpp
T& operator=(const T& other);
```

### 示例：

```cpp
class Person {
public:
    Person& operator=(const Person& other) {
        std::cout << "拷贝赋值运算符被调用\n";
        return *this;
    }
};

Person p1;
Person p2;
p2 = p1; // ← 调用了拷贝赋值运算符
```

---

## 关键区别总结：

| 区别点     | 拷贝构造                | 拷贝赋值                           |
| ------- | ------------------- | ------------------------------ |
| 触发时机    | 用一个对象“**新建**”另一个对象时 | 将一个对象“**赋值给已有对象**”时            |
| 是否已存在对象 | ❌ 新对象               | ✅ 已存在对象                        |
| 函数形式    | `T(const T& other)` | `T& operator=(const T& other)` |
| 返回值类型   | 无（构造函数）             | 返回 `T&`，支持链式赋值                 |

---

## 例子：

```cpp
class A {
public:
    A() {}
    A(const A& other) {
        std::cout << "拷贝构造函数\n";
    }

    A& operator=(const A& other) {
        std::cout << "拷贝赋值运算符\n";
        return *this;
    }
};

int main() {
    A a1;
    A a2 = a1; // 拷贝构造

    A a3;
    a3 = a1;   // 拷贝赋值
}
```

**输出：**

```
拷贝构造函数
拷贝赋值运算符
```
禁止拷贝（即禁用拷贝构造函数和拷贝赋值运算符）在 C++ 中是一个非常重要的设计策略，目的主要是为了：

# 为什么禁止拷贝？ = delete

## ✅ **1. 防止资源的重复释放（避免“浅拷贝”带来的灾难）**

如果一个类内部管理的是**动态资源**（如内存、文件句柄、互斥锁等），那么默认的拷贝行为会复制指针，而不是资源本身。这就会出现两个对象指向同一块资源，当它们都析构时：

> ⚠️ **重复释放** → 程序崩溃（double free）。

### 🧨 示例：

```cpp
class Dangerous {
public:
    int* data;
    Dangerous() {
        data = new int(42);
    }
    ~Dangerous() {
        delete data;
    }
};

Dangerous a;
Dangerous b = a; // 默认拷贝构造，data 指针被复制！
```

`a` 和 `b` 都试图 `delete data`，程序崩了！

---

## ✅ **2. 保证唯一性（例如单例、互斥量、文件句柄）**

某些类希望对象是**唯一的**，比如：

* `std::unique_ptr`
* `std::mutex`
* `Singleton` 模式类

如果能被拷贝，那“唯一性”就破坏了。

### 📦 举个例子：

```cpp
std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p2 = p1; // ❌ 拷贝被禁用！
```

因为 `unique_ptr` 的设计目标是：**一个资源只能由一个智能指针拥有**，所以它的拷贝构造和赋值函数都被 `= delete` 禁用了。

---

## ✅ **3. 提高安全性（防止误用）**

有些类从语义上就**不应该拷贝**，比如线程类、锁对象、网络连接等。

禁止拷贝可以防止开发者无意中这样写：

```cpp
std::thread t1(...);
std::thread t2 = t1; // ❌ 被禁止！线程不能拷贝
```

---

## ✅ **4. 显式表达类的语义**

如果你禁止拷贝，就明确告诉其他程序员：

> 这个类**不支持拷贝行为**，你必须使用其他方式传递（比如引用、指针或移动语义）。

---

## ✅ **5. 避免隐藏的性能开销**

默认拷贝行为可能在不经意间**复制大量数据**，导致程序性能下降。

禁止拷贝让你必须显式控制对象的传递和复制。

---

## 🧠 总结表：

| 场景                       | 禁止拷贝的原因    |
| ------------------------ | ---------- |
| 管理资源（new/delete、文件等）     | 避免重复释放     |
| 保持唯一性（mutex、unique\_ptr） | 避免多份副本     |
| 语义限制（线程、锁）               | 防止逻辑错误     |
| 性能考虑                     | 避免隐式、低效的复制 |

---

是否也想了解“如何让对象可以移动但不能拷贝”？这就是现代 C++11 的 **移动语义**（move constructor）设计思路。

函数指针（**Function Pointer**）是 C++ 中的一种语法结构，表示：

> **指向函数的指针变量**，它可以保存函数的地址，并通过它调用该函数。

也就是说，**你可以像传变量一样，传递和调用函数本身。**

---

# 函数指针

## ✅ 函数指针的基本语法

### 🌟 定义格式：

```cpp
返回类型 (*指针名)(参数类型列表);
```

### 🌟 示例：

```cpp
// 一个普通函数
void sayHello() {
    std::cout << "Hello!" << std::endl;
}

// 定义函数指针类型（指向返回 void、无参数的函数）
void (*funcPtr)() = sayHello;

// 调用函数（通过函数指针）
funcPtr();  // 输出 Hello!
```

---

## 🧠 理解函数指针的重点：

| 元素              | 含义                             |
| --------------- | ------------------------------ |
| `void (*fp)()`  | 表示 fp 是一个函数指针，指向返回 void、无参数的函数 |
| `fp = sayHello` | 函数名本质就是函数的地址                   |
| `fp()`          | 通过函数指针调用函数                     |

---

## 📦 带参数的函数指针示例：

```cpp
int add(int a, int b) {
    return a + b;
}

// 定义一个指针，指向返回 int、接收两个 int 参数的函数
int (*op)(int, int) = add;

std::cout << op(2, 3); // 输出 5
```

---

## 📚 用途场景

| 场景         | 用法                 |
| ---------- | ------------------ |
| 回调机制（函数参数） | 把函数指针当参数传给另一个函数    |
| 实现策略模式     | 根据用户选择，调用不同函数      |
| 简化逻辑       | 把函数当数据处理（尤其 C 风格中） |

---

## ✅ 举个“函数指针作为参数”的例子：

```cpp
void compute(int a, int b, int (*func)(int, int)) {
    std::cout << "结果: " << func(a, b) << std::endl;
}

int add(int x, int y) { return x + y; }
int mul(int x, int y) { return x * y; }

compute(3, 4, add);  // 输出 7
compute(3, 4, mul);  // 输出 12
```

---

## 🆚 函数指针 vs `std::function`

| 特点           | 函数指针            | `std::function` |
| ------------ | --------------- | --------------- |
| 支持 lambda/闭包 | ❌ 不支持           | ✅ 支持            |
| 可空性          | ✅ 可以为 `nullptr` | ✅ 可为空           |
| 灵活性          | 较低（只能指向函数）      | 非常高（任何可调用对象）    |
| 使用复杂度        | 简单（C 风格）        | 略复杂（需模板）        |

---

## ✅ 总结一句话：

> **函数指针 = 能存储函数地址的变量，用来调用或传递函数。**

---

# 回调函数

## ✅ 回调函数（Callback）是什么？

> 回调函数就是**你传给某个对象或函数的函数**，在**特定事件发生时由对方调用你传进去的函数**。

简单说就是：

> **我把函数给你，你在合适的时候帮我调用它。**

---

## 🔧 举个生活例子类比：

你报名快递取件，留了电话（这就是回调函数）：

* 快递公司不知道你具体要干嘛（逻辑交给你），只管在快递到了以后**回拨你留的电话**。
* 你负责处理收到快递以后的事。

---

## 📦 在代码中怎么用？

```cpp
channel.setReadCallback([](Timestamp t) {
    std::cout << "收到读事件！时间戳：" << t.toString() << std::endl;
});
```

这里：

* `setReadCallback(...)` 传入了一个 lambda 函数；
* 当网络有数据可读时，底层会自动调用你传入的函数；
* 你不需要在内部循环中写死逻辑，只需要注册自己的处理函数。

---

## ✅ 为什么要用回调函数？

| 优点   | 说明                               |
| ---- | -------------------------------- |
| 解耦   | 库/模块只负责触发事件，**不关心怎么处理事件**        |
| 灵活   | 用户可以**自定义行为**（比如日志、发送数据等）        |
| 异步驱动 | 和事件驱动模型配合使用，如 Reactor、epoll、IOCP |

---

## 🔍 看看你提供的代码：

```cpp
void setReadCallback(ReadEventCallback cb)
{ readCallback_ = std::move(cb); }
```

这表示你可以传入一个“读事件处理函数”，比如 lambda 或普通函数指针。

当 `Channel` 检测到 fd 可读时，它就会这么用：

```cpp
if (readCallback_) readCallback_(timestamp); // 触发回调
```

这就是典型的 **事件响应机制：注册 + 触发**。

---

## 💡 总结一句话：

> 回调函数就是“**当某事发生时，我要做什么事**”的代码形式，先注册，后调用。

---