# C++11 新特性

- auto类型推导
- 智能指针
- RAII lock
- `std::thread`
- 左值右值
- `std::function` 和 `lambda` 表达式

# 智能指针

 **智能指针（Smart Pointer）** 是一种**封装了裸指针（原始指针）**的类，用来**自动管理动态分配的内存资源**，防止内存泄漏和悬空指针等常见问题。

三种：`std::unique_ptr` `std::shared_ptr` `std::weak_ptr`

---

## 为什么需要智能指针？

用 `new` 分配内存后，程序员需要手动 `delete`，否则就会**内存泄漏**：

```cpp
int* p = new int(10);
// 如果忘了 delete p; --> 泄漏！
```

智能指针帮你自动调用 `delete`，**RAII 资源获取即初始化**思想的一部分。

---

## C++中常见的智能指针类型（来自 `<memory>` 头文件）

| 智能指针              | C++版本 | 特点                               |
| ----------------- | ----- | -------------------------------- |
| `std::unique_ptr` | C++11 | 独占所有权，不能复制，只能移动                  |
| `std::shared_ptr` | C++11 | 引用计数共享所有权，最后一个自动释放资源             |
| `std::weak_ptr`   | C++11 | 不增加引用计数，配合 `shared_ptr` 解决循环引用问题 |

---

## 1️⃣ `std::unique_ptr` —— 独占资源

独占所有权，同一时间只能由一个unique_ptr指向一个特定的对象。

当其销毁时，它所指向的对象也会被销毁。

使用场景：

需要确保一个对象只被一个指针所拥有时。

需要自动管理资源，如文件句柄或互斥锁。

```cpp
#include <memory>

std::unique_ptr<int> ptr = std::make_unique<int>(42); // 推荐使用 make_unique

// 自动释放，不需要 delete
```

不能复制：

```cpp
std::unique_ptr<int> ptr2 = ptr; // ❌ 编译错误
std::unique_ptr<int> ptr3 = std::move(ptr); // ✅ 允许移动
```

---

## 2️⃣ `std::shared_ptr` —— 共享资源（引用计数）

共享所有权，多个shared_ptr可以指向同一个对象。

内部使用引用计数来确保只有当最后一个指向对象的shared_ptr被销毁时，对象才会被销毁。

使用场景：

需要再多个所有者之间共享对象时。

需要通过复制构造函数或赋值操作符来复制智能指针时。

```cpp
#include <memory>

std::shared_ptr<int> a = std::make_shared<int>(100);
std::shared_ptr<int> b = a; // ✅ 引用计数 +1

// 当最后一个 shared_ptr 被销毁时，资源才释放
```

适合多个对象**共享同一个资源**。

---

## 3️⃣ `std::weak_ptr` —— 非拥有型弱引用

不拥有对象所有权的智能指针，指向一个由shared_ptr管理的对象。

weak_ptr用于解决shared_pre之间的循环引用问题。

使用场景：

需要访问但不拥有由shared_ptr管理的对象时。

需要解决shared_ptr之间的循环引用问题时。

注：weak_ptr要和shared_ptr搭配使用。

```cpp
#include <memory>

std::shared_ptr<int> a = std::make_shared<int>(5);
std::weak_ptr<int> w = a;

if (auto s = w.lock()) { // 判断 shared_ptr 是否还存在
    std::cout << *s << std::endl;
}
```

用途：解决 `shared_ptr` 循环引用问题（比如互相引用的对象）。

---

## 智能指针 vs 裸指针

| 比较项      | 裸指针 (`int*`) | 智能指针           |
| -------- | ------------ | -------------- |
| 是否自动释放内存 | ❌            | ✅              |
| 支持引用计数   | ❌            | `shared_ptr` ✅ |
| 支持转移所有权  | ❌            | `unique_ptr` ✅ |
| 出错可能性    | 高            | 低（但不是零）        |

---

## 总结

智能指针是现代 C++ 编程的标配，用于：

* 避免内存泄漏
* 简化内存管理
* 提高代码可读性和安全性

---

# decltype

## 概念

- **`decltype` 是 C++11 引入的新特性。**
- 它是一个**编译期运算符**，**作用是推断一个表达式（变量、操作、函数调用）的类型**。
- `decltype(x)` 本身不是类型，它是让编译器生成**x对应的类型**，可以用来声明变量、做模板参数等等。
- **保留所有修饰性**：如果 `x` 是引用，`decltype(x)` 推断出来也是引用；如果是 const，decltype也保留 const。
  
## 核心用途

| 用途 | 例子 |
|:---|:---|
| 推断变量类型 | `decltype(a) b;` （b 和 a 同类型） |
| 推断表达式类型 | `decltype(a+b) c;` （c 的类型是 a+b 的结果类型） |
| 推断函数返回值类型 | `auto func() -> decltype(x+y)` |
| 用在复杂模板中类型推导 | 保持类型一致、避免手写类型 |

## decltype 与 auto 的区别

| 特性           | decltype                             | auto                                |
|:---------------|:-------------------------------------|:-----------------------------------|
| 主要作用       | 推断**表达式的类型**（不做初始化）   | 推断**初值的类型**（并且初始化）   |
| 是否需要初值   | ❌ 不需要初值                        | ✅ 必须有初值                      |
| 保留引用/const | ✅ 保留（比如 `const int&`）         | ❌ 默认丢失，需要手动加 `&` 或 `const` |
| 适合场景       | 精确类型推导（包括引用/const场景）   | 简单推断变量类型并初始化           |

---
- **`auto`** 侧重于**推断初始化表达式的类型，并且自动初始化**。(`auto` = 自动推断并赋值)
- **`decltype`** 侧重于**推断任意表达式本身的类型（保留 const/ref 属性）**，不需要初值。(`decltype` = 精准拿到类型本身。)
---

| 示例                           | 说明                                   |
|:-------------------------------|:-------------------------------------|
| `decltype(x) y;`               | y 的类型和 x 完全一致，包括 const/ref |
| `auto y = x;`                  | y 的类型是 x 的值类型（通常是复制）    |
| `auto& y = x;`                 | y 是 x 的引用                        |
| `auto&& y = expr;`             | y 是 expr 的右值引用（完美转发用）    |