# decltype

## 概念

- **`decltype` 是 C++11 引入的新特性。**
- 它是一个**编译期运算符**，**作用是推断一个表达式（变量、操作、函数调用）的类型**。
- `decltype(x)` 本身不是类型，它是让编译器生成**x对应的类型**，可以用来声明变量、做模板参数等等。
- **保留所有修饰性**：如果 `x` 是引用，`decltype(x)` 推断出来也是引用；如果是 const，decltype也保留 const。
  
## 核心用途

| 用途 | 例子 |
|:---|:---|
| 推断变量类型 | `decltype(a) b;` （b 和 a 同类型） |
| 推断表达式类型 | `decltype(a+b) c;` （c 的类型是 a+b 的结果类型） |
| 推断函数返回值类型 | `auto func() -> decltype(x+y)` |
| 用在复杂模板中类型推导 | 保持类型一致、避免手写类型 |

## decltype 与 auto 的区别

| 特性           | decltype                             | auto                                |
|:---------------|:-------------------------------------|:-----------------------------------|
| 主要作用       | 推断**表达式的类型**（不做初始化）   | 推断**初值的类型**（并且初始化）   |
| 是否需要初值   | ❌ 不需要初值                        | ✅ 必须有初值                      |
| 保留引用/const | ✅ 保留（比如 `const int&`）         | ❌ 默认丢失，需要手动加 `&` 或 `const` |
| 适合场景       | 精确类型推导（包括引用/const场景）   | 简单推断变量类型并初始化           |

---
- **`auto`** 侧重于**推断初始化表达式的类型，并且自动初始化**。(`auto` = 自动推断并赋值)
- **`decltype`** 侧重于**推断任意表达式本身的类型（保留 const/ref 属性）**，不需要初值。(`decltype` = 精准拿到类型本身。)
---

| 示例                           | 说明                                   |
|:-------------------------------|:-------------------------------------|
| `decltype(x) y;`               | y 的类型和 x 完全一致，包括 const/ref |
| `auto y = x;`                  | y 的类型是 x 的值类型（通常是复制）    |
| `auto& y = x;`                 | y 是 x 的引用                        |
| `auto&& y = expr;`             | y 是 expr 的右值引用（完美转发用）    |